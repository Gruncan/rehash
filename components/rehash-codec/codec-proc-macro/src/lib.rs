use proc_macro::TokenStream;
use std::fs::{write, File, OpenOptions};
use std::io::Write;
use std::path::{Path, PathBuf};
use std::sync::OnceLock;
use syn::__private::quote::quote;
use syn::{parse_macro_input, ItemFn};


const FFI_OUT_ENV: &'static str = "FFI_OUT_DIR";
const FFI_FILE_NAME: &'static str = "codec_ffi.rs";

static FFI_GEN_OUTPUT_PATH: OnceLock<PathBuf> = OnceLock::new();
static FFI_GEN_FILE: OnceLock<Option<File>> = OnceLock::new();

fn get_generated_path() -> &'static PathBuf {
    FFI_GEN_OUTPUT_PATH.get_or_init(|| {
        let out_dir = PathBuf::from(std::env::var(FFI_OUT_ENV).expect("FFI_OUT_ENV is not set"));
        Path::new(&out_dir).join(FFI_FILE_NAME)
    })
}

fn get_generated_file() -> &'static Option<File> {
    FFI_GEN_FILE.get_or_init(|| {
        let path = get_generated_path();

        if !path.exists() {
            match write(&path, "// Generated by `rehash-codec`\n").ok() {
                Some(_) => (),
                None => return None,
            }
        }

        OpenOptions::new()
            .create(true)
            .append(true)
            .open(path).ok()
    })
}

#[proc_macro_attribute]
pub fn rehash_codec_ffi(attr: TokenStream, item: TokenStream) -> TokenStream {
    let input_fn = parse_macro_input!(item as ItemFn);
    let fn_name = &input_fn.sig.ident;
    let inputs = &input_fn.sig.inputs;
    let outputs = &input_fn.sig.output;
    // let generics = &input_fn.sig.generics;
    let block = &input_fn.block;

    let fn_ffi_gen = quote! {
        #[unsafe(no_mangle)]
        pub unsafe extern "C" fn #fn_name(#inputs) #outputs
                #block
    };

    let file = get_generated_file();
    match file {
        Some(file) => {
            let mut file = file;
            writeln!(file, "{}", fn_ffi_gen)
                .expect(format!("Failed to write to generated function {}", fn_name)
                    .as_str());
        },
        None => {}
    }


    quote!(#input_fn).into()
}